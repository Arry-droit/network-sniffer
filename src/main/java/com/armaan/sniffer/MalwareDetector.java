package com.armaan.sniffer;

import org.pcap4j.packet.*;
import java.util.HashSet;
import java.util.Set;

public class MalwareDetector {
    private static final Set<Integer> SUSPICIOUS_PORTS = new HashSet<>();
    private static final Set<String> KNOWN_MALWARE_IPS = new HashSet<>();

    static {
        // Common ports used by malware
        SUSPICIOUS_PORTS.add(4444); // Metasploit
        SUSPICIOUS_PORTS.add(6667); // IRC (often used by bots)
        SUSPICIOUS_PORTS.add(8080); // Common malware C&C
        SUSPICIOUS_PORTS.add(31337); // Back Orifice
        SUSPICIOUS_PORTS.add(54321); // NetBus
    }

    public static class DetectionResult {
        private final boolean isMalicious;
        private final String reason;
        private final String severity;

        public DetectionResult(boolean isMalicious, String reason, String severity) {
            this.isMalicious = isMalicious;
            this.reason = reason;
            this.severity = severity;
        }

        public boolean isMalicious() {
            return isMalicious;
        }

        public String getReason() {
            return reason;
        }

        public String getSeverity() {
            return severity;
        }
    }

    public static DetectionResult analyzePacket(Packet packet) {
        IpV4Packet ipV4 = packet.get(IpV4Packet.class);
        if (ipV4 == null) {
            return new DetectionResult(false, "Not an IPv4 packet", "INFO");
        }

        String sourceIP = ipV4.getHeader().getSrcAddr().getHostAddress();
        String destIP = ipV4.getHeader().getDstAddr().getHostAddress();

        // Check for known malicious IPs
        if (KNOWN_MALWARE_IPS.contains(sourceIP) || KNOWN_MALWARE_IPS.contains(destIP)) {
            return new DetectionResult(true, "Known malicious IP address", "HIGH");
        }

        // Check TCP packets
        if (packet.contains(TcpPacket.class)) {
            TcpPacket tcp = packet.get(TcpPacket.class);
            if (tcp != null) {
                int srcPort = tcp.getHeader().getSrcPort().value();
                int dstPort = tcp.getHeader().getDstPort().value();

                // Check for suspicious ports
                if (SUSPICIOUS_PORTS.contains(srcPort) || SUSPICIOUS_PORTS.contains(dstPort)) {
                    return new DetectionResult(true,
                            "Suspicious port detected: " + (SUSPICIOUS_PORTS.contains(srcPort) ? srcPort : dstPort),
                            "MEDIUM");
                }

                // Check for suspicious TCP flags
                TcpPacket.TcpHeader header = tcp.getHeader();
                if (header.getSyn() && !header.getAck()) {
                    // Potential port scan
                    return new DetectionResult(true, "Potential port scan detected", "MEDIUM");
                }

                // Check for large payload size
                if (tcp.getPayload() != null && tcp.getPayload().length() > 1000) {
                    return new DetectionResult(true, "Large payload size detected", "LOW");
                }
            }
        }

        // Check UDP packets
        if (packet.contains(UdpPacket.class)) {
            UdpPacket udp = packet.get(UdpPacket.class);
            if (udp != null) {
                int srcPort = udp.getHeader().getSrcPort().value();
                int dstPort = udp.getHeader().getDstPort().value();

                if (SUSPICIOUS_PORTS.contains(srcPort) || SUSPICIOUS_PORTS.contains(dstPort)) {
                    return new DetectionResult(true,
                            "Suspicious UDP port detected: " + (SUSPICIOUS_PORTS.contains(srcPort) ? srcPort : dstPort),
                            "MEDIUM");
                }
            }
        }

        return new DetectionResult(false, "No suspicious activity detected", "INFO");
    }
}